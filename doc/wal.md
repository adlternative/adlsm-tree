### 为什么需要预写日志 (Write Ahead Log)

在 `adlsm-tree` 的实现逻辑中，我们的写入会先进入 `memTable` , 然后一段时间等到检验到 `memtable` 的大小大于一定的阀值才会触发 `minor compaction`，也就是 `memtable` -> `imem_table` -> `sstable` 这个过程。如果在此过程中数据库或者机器崩溃，那么内存中的部分数据就会丢失，等到下一次启动也无法找到这些数据。

有两种可能的解决方案：

1. write ahead log

 所有的数据都先 `fsync` 到预写日志中，然后再写入到 `memtable` 中（从而对客户端的读可见）， Put() 或者 Delete() 才会返回。（客户端的读取与预写日志的落盘同步）即使发生了崩溃，下次重启仍然可以恢复这些数据，然后就可以正常的读取。正如周子龙说的那样：这类似于 2PC 中，只有当协调者和参与者确保日志真正已经落盘，才会通知对方状态发生了改变，而不是在仅仅在内存中跑一圈 `prepare`, `commit`, `abort`。（预写日志保证数据真没丢）

2. shadow page

 完全摒弃 `memtable`，所有数据都必须落盘，然后才可以更新元数据文件，然后客户端才可以进行读取。（客户端的读取与元数据文件的落盘同步）这样也就不需要预写日志了。如果发生了崩溃，如果记录元数据已经正常更新，那么最后的写入是可见的；反之，上次的写入发生错误，客户端应当通过某种形式得知失败，并进行重试。当然 `adlsm-tree` 已经用了 `memtable`，所以不会选择该方案。（元数据落盘保证数据真没丢）

核心：数据真正写入成功（无论通过哪种形式保证） --> 数据对客户端可见。

原子性
持久性